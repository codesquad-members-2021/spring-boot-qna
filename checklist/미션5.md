### 미션 5

 
### AJAX로 답변 추가 기능 구현
질문에 답변을 추가하는 화면이 깜빡이지 않으면서(AJAX 활용) 답변을 추가한다. 즉, 화면을 새로고침하지 않고 변경된 사항만 ajax을 통해 반영되도록 수정.

- [X] 버튼 클릭 이벤트 핸들러 등록 
  - scripts.js에 구현
   ```javascript
   $(".submit-write button[type=submit]").click(addAnswer);
   ```
- [X] 서버로 보낼 form 데이터 묶기
   ```javascript
    function addAnswer(e) {
        e.preventDefault(); //submit 이 자동으로 동작하는 것을 막는다.
    
  //form data들을 자동으로 묶어준다.
  // key-value 형태로 반환-> contents = "입력한 답변"
        var queryString = $(".submit-write").serialize(); 
        console.log("query : "+ queryString);
    }
   ```
- [X] 서버로 데이터를 전송
   ```javascript
   function addAnswer(e) {
        e.preventDefault();
        
        var queryString = $("form[name=answer]").serialize();
    
        var url = $(".answer-write").attr("action");
        console.log("url : " + url);
        
        $.ajax({
            type : 'post',
            url : url,
            data : queryString,
            dataType : ' json',
            error: onError,
            success : onSuccess,
        });
    }
   ```
- [X] 서버에서 데이터 처리 및 JSON 응답
   - 클래스 명 수정 
      - AnswerController → ApiAnswerController
    - `@Controller`대신 `@RestController` 어노테이션 추가
    - create() 메소드 수정 
      - 기존 코드
      ```java
        @PostMapping
        public String create(@PathVariable long questionId, String contents, HttpSession session) {
            //.. 
            return "redirect:/questions/" + questionId;       
        }
      ```
      - 수정 뒤
      ```java
        @PostMapping
        public Answer create(@PathVariable long questionId, String contents, HttpSession session) {
            //.. 
            Answer answer = new Answer(loginUser, question, contents);
            return answerRepository.save(answer);   // 👈👈 Answer 객체를 그대로 리턴
        }
      ```
      - getter 대신 엔티티 필드 변수에`@JsonProperty` 추가
      - 보여주고싶지 않은 데이터, 필드 변수에  `@JsonIgnore` 추가
- [X] 클라이언트(크롬)에서 JSON 응답 확인
   - addAnswer(e) 함수 수정
     - 값을 정상적으로 받아오지 못했을 경우(error), failure 출력
     - 값을 정상적으로 받아왔을 경우(success), 서버에서 받아온 data 출력
    
     ```javascript
     function addAnswer(e) {
      e.preventDefault();
    
      var queryString = $("form[name=answer]").serialize();
    
      var url = $(".answer-write").attr("action");
      console.log("url : " + url);
    
      $.ajax({
          type : 'post',
          url : url,
          data : queryString,
          dataType : 'json',
          error: function () {
            console.log('failure');
            },
          success : function (data, status) {
            console.log(data);
            }
        });
      }
     ```
     
- [X] 클라이언트에서 JSON 데이터 처리
    - ajax에서 success일 경우 호출하는 함수 변경
    ```javascript
       success : function (data, status) {
            console.log(data);
  // 답변 템플릿 가져옴
            var answerTemplate = $("#answerTemplate").html();
  // 변경된 정보 템플릿에 붙이기
            var template = answerTemplate.format(data.writer.userId, data.formattedCreateDate, data.contents, data.question.id, data.id);
  // 댓글들 가장 마지막에 변경된 답변 붙이기
            $(".qna-comment-slipp-articles").prepend(template);            
            $("textarea[name=contents]").val("");
        }
    ```

### AJAX로 답변 삭제 기능 구현
- [X] 모든 삭제 링크 선택
   ```javascript
    $(".delete-answer-form button[type='submit']").click(deleteAnswer);
   ```

- [X] 상위 form 태그의 url(action 속성) 구하기
   - 클릭한 삭제 버전 엘리먼트는 this로 가능함(`$(this)`)
     - 일단 console.log()로 확인해보자
       ```javascript
        function deleteAnswer(e) {
            console.log(this);
        }
       ```
     - 이후 this 값을 local 변수에 저장해서 사용
       ```javascript
        var deleteBtn = $(this);
       ```
   - 부모 태그 접근
     - parent() function 사용
    
- [X] ajax 호출 구현
     ```javascript
     function deleteAnswer(e) {
     // ...
    
      $.ajax({
          type : 'delete',
          url : url,
          data : queryString,
          dataType : 'json',
          error: function () {
            console.log('failure');
            },
          success : function (data, status) {
            console.log(data);
            }
        });
      }
     ```
- [X] Result 클래스 활용
  - Result 대신 ResponseResult가 조금 더 명확한 네이밍일 듯
  - domain 패키지 아래 위치
  - 답변 삭제 성공 → Result.ok()
  - 실패 → Result.fail(“error message”)
  - [참고](https://www.youtube.com/watch?v=g-nsT3NRK2o)
    
- [X] html에서 답변 삭제
  - 서버 응답 status 값 == true → 답변 삭제
    ```javascript
    function deleteAnswer(e) {
        var deleteBtn = $(this);
        
        $.ajax({
            [...],
            success : function (data, status) {            
                deleteBtn.closest("article").remove();
            }
        });
    }
    ```
   - 클릭한 element($(this))에서 가장 가까운 article element를 찾아 삭제(remove function)
    
### Swagger 문서화
 - gradle 의존성 - [참고](http://springfox.github.io/springfox/docs/current/#gradle)
 - MvcConfig 빈 설정 - [참고](https://springboot.tistory.com/23)
 - "http://localhost:8080/swagger-ui/"로 접속해야 함

### 🚨 에러 발생

#### HttpMessageNotWritableException 예외 발생
  - * 단방향일 때
  - 예외 메시지 : Could not write JSON: failed to lazily initialize a collection of role
  - 원인 : User 클래스에 만들어준 Answer 리스트에 설정된 지연로딩 설정(fetch = FetchType.LAZY) 
      → 실제 객체가 아닌 프록시 객체를 참조하게 되어버림
  - 해결 : fetch = FetchType.EAGER 로 수정
  - 궁금한 점 : User 내부에 있는 Answer 리스트는 eager 옵션을 꼭 달아주어야하는 반면, Question에 있는 Answer 리스트는 eager 옵션 없이도 동작
  - [참고](https://stackoverflow.com/questions/42089966/could-not-write-content-failed-to-lazily-initialize-a-collection-of-role)

#### Question 삭제 시, Answer 삭제되지 않는 문제 발생
  - * 양방향으로 수정 후
  - 해결 : User 클래스의 fetch 옵션 삭제해주니 정상 작동
  - ```java
     // User 클래스
    @OneToMany(mappedBy = "writer", cascade = CascadeType.ALL, fetch = FetchType.EAGER) // 👈 이번에는 이 fetch 옵션이 문제였음
    private List<Answer> answers = new ArrayList<>();
    ```
  - JPA 너무 어렵드앙 왜 이런지는 모르겠지만 어쨌든 이제 둘 다 delete 영속성 전이

#### 순환참조 에러 발생
  - 양방향으로 바꿔준 뒤 아래와 같은 에러 발생
  - ```java
    domain.question.Question["answers"]->org.hibernate.collection.internal.PersistentBag[0]->com.codessquad.qna.web.domain.answer.Answer["question"]->com.codessquad.qna.web.domain.question.Question["answers"]->org.hibernate.collection.internal.PersistentBag[0]->
    ```
  - setter 메소드도 순환참조를 고려해 작성해주었지만 여전히 에러 발생  
  - 해결 : `@OneToMany`인 리스트에 `@JsonIgnore` 추가 시 정상 작동
  - [참조](https://stackoverflow.com/questions/35346794/infinite-recursion-with-jackson-json-and-hibernate-jpa-issue-yet-another)

#### ajax을 통해 response로 Object 데이터 전송 실패 (406 에러)
 - ApiAnswerController에서 ResponseResult 객체를 리턴하는데 계속 406 에러가 떴다.
 - 해결 : ResponseResult에 getter를 추가
 - 해당 object는 반드시 getter를 가지고 있어야 한다..

### 추가 구현해야할 것들
- [ ] show.html, index.html 에서 댓글 개수 카운트하는 방식 수정
    - script.js 파일에 function 추가해야할 듯

