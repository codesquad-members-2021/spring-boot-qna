### 미션4. 객체-관계 매핑

### User와 Question 연결 - 이미 미션 3에서 구현
> 현재 Question의 글쓴이는 User의 name 값을 가지는 것으로 구현했다.

> 이와 같이 구현하는 경우 User의 name을 수정하는 경우 Question의 글쓴이와 다른 값을 가지는 문제가 발생한다.
> 이 문제를 해결하기 위해 User의 name이 변경될 때마다 Question의 writer 값을 수정할 수도 있지만 이와 같이 구현할 경우 writer가 같은 이름을 가지는 경우 문제가 될 수 있다.

> 이 같은 문제 상황에 대해 원론적으로 문제가 발생하지 않도록 해결한다.

- [X] @ManyToOne 매핑
  ```java
    @Entity
 public class Question {
       @ManyToOne
  @JoinColumn(foreignKey = @ForeignKey(name = "fk_question_writer"))
       private User writer;

         [...]
      }
   ```


### 답변 추가하기 - 이미 미션 3에서 구현
> 사용자는 질문 상세보기 화면에서 답변 목록을 볼 수 있다.

> 로그인한 사용자는 답변을 추가할 수 있다.

> 자신이 쓴 답변을 삭제할 수 있다.

- [X] Answer에 @ManyToOne
  ```java
   @Entity
 public class Answer {
      @ManyToOne
  @JoinColumn(foreignKey = @ForeignKey(name = "fk_answer_to_question"))
         private Question question;

          [...]
     }
  ```
- [X] AnswerRepository
  - findByQuestionId(questionId)와 같은 메소드를 추가

- [X] Answer url
  - "/questions/{questionId}/answers/{id} "


### @OneToMany 매핑 전략 - 이미 미션 3에서 구현
- [X] Question이 Answer와 @OneToMany 관계
  - “question”은 Answer에서 @ManyToOne으로 매핑한 필드의 이름
  ```java
  @OneToMany(mappedBy="question")
  ```

### 답변 삭제하기 - 이미 미션 3에서 구현
- [X] 답변 삭제 메소드 추가
  - @DeleteMapping
  - url : "/questions/{questionId}/answers/{id}"

### 질문 삭제하기 실습(선택)
- ✔ 질문을 삭제할 때 답변 또한 삭제해야 하며, 답변의 삭제 또한 삭제 상태(deleted)를 변경

- [X] soft-deleted
  - 질문 데이터를 완전히 삭제하는 것이 아니라 데이터의 상태를 삭제 상태(deleted - boolean type)로 변경한다.

- [X] 삭제 가능한 경우
  - 로그인 사용자와 질문한 사람이 같은 경우
  - 답변이 없는 경우
  - 질문자와 답변 글의 모든 답변자 같은 경우

- [X] 삭제 불가능한 경우
  - 질문자와 답변자가 다른 경우 답변을 삭제할 수 없다.


### soft-deleted
#### 그냥 delete과 무엇이 다른가?
  - [참고](https://github.com/spring-projects/spring-data-jpa/issues/676#issuecomment-752422516)
   ```text
    Generally a delete has the following impacts:

    - Delete the entity (DELETE op)
    - Cascade the DELETE op

    And soft delete changes the delete action in the following ways:

    - Mark entity as deleted/inactive (UPDATE op)
    - Filter all fetch queries to find active records only
    - Cascade the inactive marking (or soft delete) to other elements
   ```
  - delete은 말 그대로 db에서 **삭제**
  - soft-delete은 해당 데이터의 상태를 inactive로 **업데이트** 해준다. delete 상태를 active를 통해 관리하는 것이 soft-delete
#### 왜 필요한가?
  - [참고](https://dzone.com/articles/to-delete-or-to-soft-delete-that-is-the-question)
  - 주된 이유는 기술적인 이유보다는 사용성 때문..?
    1. History tracking and audit (e.g. for legal reasons)
    2. Keeping reference integrity and avoid cascade delete
    3. You need “Graceful” delete. E.g. a long-running business process may need data that might be “deleted”, but still required for this particular process to finish

#### 어떻게 사용하는가?
  - [참고](https://stackoverflow.com/a/33168644)
  - `#{#entityName}` 사용
  - ```java
	  //Override CrudRepository or PagingAndSortingRepository's query method:
	  @Override
	  @Query("select e from #{#entityName} e where e.deleteFlag=false")
	   public List<T> findAll();
    ```

#### isActive 업데이트 방식 고민
- 쿼리문을 통해 직접 update
	 ```java
	  @Query("UPDATE #{#entityName} q SET q.isActive=false WHERE q.id=?1")
	  @Modifying
	  void softDelete(long id);
    ```

 - @DeleteMapping을 사용하는데 delete() 메소드를 사용하지 않아서 에러 발생
    - 디폴트 메소드로 delete() 메소드 재정의
    ```java
     @Query("UPDATE #{#entityName} q SET q.isActive=false WHERE q.id=?1")
     @Modifying
     void softDelete(Long id);

     @Override
     default void delete(Question question) {
         softDelete(question.getId());
     }
    ```

- 더티체킹 방식 사용
  ```java
  public void delete(long id, HttpSession session){
     Question question = authenticate(id, session);
     question.setDelete(); // 내부적으로 question.isActive = false;  questionRepository.save(question);
  }
  ```


### 🚨 자질구레 에러

- `@Column(name="is_active")` 추가 시 'Cannot resolve column' 에러 발생
  - Unresolved database references in annotations 옵션을 off - [참조](https://stackoverflow.com/questions/29155350/jpa-cannot-resolve-column-intellij)
- update'@Modifying'
  - @Modifying 반드시 추가해 주어야 함
  - @Modifying annotation include INSERT, UPDATE, DELETE, and DDL statements. - [참조](https://stackoverflow.com/questions/19323557/handling-soft-deletes-with-spring-jpa)
  - clearAutomatically와 flushAutomatically 옵션 존재 - [참조](https://www.baeldung.com/spring-data-jpa-modifying-annotation#clear)
    - 아직 정확하게 왜 써야하는지는 잘 모르겠음, 알아만두자

### 수정 및 리펙토링
 - [X] @~Mapping() → @~Mapping
 - [ ] 단방향 매핑으로 수정
 - [X] DateTimeUtils 클래스 구현
   - 대신 
       ```java
        private static final DateTimeFormatter DATE_TIME_FORMATTER = DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss");
       ```
   
 - [X] `@Column(name="is_active")`
    - 굳이 is_active라고 설정해주지 않아도 됨.
    - (+) @Column 디폴트 속성 값 설정
      - `true` 값을 manually assign 해주는 대신, `columnDefinition = "boolean default true"` 사용
      - [참조](https://stackoverflow.com/questions/28207359/how-to-set-default-boolean-value-in-jpa)
    
 - [X] Builder 기본생성자를 private
    - 필수 필드변수를 받는 생성자만 public으로 
       - (이렇게 되면 private인 기본 생성자가 애초에 필요한가..?)
        - 그래서 기본 생성자는 아예 삭제
    - 

 - [X] CRUDAuthenticationException 네이밍 수정
    - CrudNotAllowedException
    - '인증'이라는 단어가 DB에서는 잘 쓰이지 않는다.
    - CRUD 모두 대문자 보다는 Crud가 더 적절해보인다.
    
 - [X] id 네이밍
    - 어떤 entity의 id인지 명확하게 밝히는 것이 좋음 (questionId, answerId .. etc)

 - [X] AnswerService create() 메소드 파라미터 수정
   - 현재 메소드 
     ```java
        public void create(long questionId, String contents, HttpSession session) { //...};
     ```
     
   - HttpSession 대신 User를 받아오는 것이 더 적절
    
- [X] `@Transactional`
   - 서비스 계층에 Transational 추가
    - 원자성을 유지해야하는 블록 단위로 설정해야 함.
    - 단순한 조회문은 readonly 설정

- [X] 메서드 이름은 동사
   - ex) QuestionService 혹은 UserService의 list() 메소드 이름 → getAnswersByQuestionId()와 같이 동사로 변경
    
- [ ] Dto 생성
   - Entity와 직접적인 관련이 없는 부분은 Entity 대신 dto 사용
   - ex) UserService에서 loginUser
      -  `User loginUser = SessionUtils.getLoginUser(session);`에서 User 엔티티 대신 UserSessionDto와 같은 dto 타입으로 담아내는 것이 좋아보인다.
