### 미션4. 객체-관계 매핑

### User와 Question 연결 - 이미 미션 3에서 구현
> 현재 Question의 글쓴이는 User의 name 값을 가지는 것으로 구현했다.

> 이와 같이 구현하는 경우 User의 name을 수정하는 경우 Question의 글쓴이와 다른 값을 가지는 문제가 발생한다.
> 이 문제를 해결하기 위해 User의 name이 변경될 때마다 Question의 writer 값을 수정할 수도 있지만 이와 같이 구현할 경우 writer가 같은 이름을 가지는 경우 문제가 될 수 있다.

> 이 같은 문제 상황에 대해 원론적으로 문제가 발생하지 않도록 해결한다.

- [X] @ManyToOne 매핑
  ```java
	 @Entity
	 public class Question {
	    @ManyToOne
	    @JoinColumn(foreignKey = @ForeignKey(name = "fk_question_writer"))
	    private User writer;

	      [...]
	   }
   ```


### 답변 추가하기 - 이미 미션 3에서 구현
> 사용자는 질문 상세보기 화면에서 답변 목록을 볼 수 있다.

> 로그인한 사용자는 답변을 추가할 수 있다.

> 자신이 쓴 답변을 삭제할 수 있다.

- [X] Answer에 @ManyToOne
  ```java
	@Entity
	 public class Answer {
	   @ManyToOne
	   @JoinColumn(foreignKey = @ForeignKey(name = "fk_answer_to_question"))
	      private Question question;

	       [...]
	  }
  ```
- [X] AnswerRepository
  - findByQuestionId(questionId)와 같은 메소드를 추가

- [X] Answer url
  - "/questions/{questionId}/answers/{id} "


### @OneToMany 매핑 전략 - 이미 미션 3에서 구현
- [X] Question이 Answer와 @OneToMany 관계
  - “question”은 Answer에서 @ManyToOne으로 매핑한 필드의 이름
  ```java
  @OneToMany(mappedBy="question")
  ```

### 답변 삭제하기 - 이미 미션 3에서 구현
- [X] 답변 삭제 메소드 추가
  - @DeleteMapping
  - url : "/questions/{questionId}/answers/{id}"

### 질문 삭제하기 실습(선택)
- ✔ 질문을 삭제할 때 답변 또한 삭제해야 하며, 답변의 삭제 또한 삭제 상태(deleted)를 변경

- [ ] soft-deleted
  - 질문 데이터를 완전히 삭제하는 것이 아니라 데이터의 상태를 삭제 상태(deleted - boolean type)로 변경한다.
- [ ] 삭제 가능한 경우
  - 로그인 사용자와 질문한 사람이 같은 경우
  - 답변이 없는 경우
  - 질문자와 답변 글의 모든 답변자 같은 경우

- [ ] 삭제 불가능한 경우
  - 질문자와 답변자가 다른 경우 답변을 삭제할 수 없다.


### soft-deleted
#### 그냥 delete과 무엇이 다른가?
  - [참고](https://github.com/spring-projects/spring-data-jpa/issues/676#issuecomment-752422516)
   ```text
    Generally a delete has the following impacts:

    - Delete the entity (DELETE op)
    - Cascade the DELETE op

    And soft delete changes the delete action in the following ways:

    - Mark entity as deleted/inactive (UPDATE op)
    - Filter all fetch queries to find active records only
    - Cascade the inactive marking (or soft delete) to other elements
   ```
  - delete은 말 그대로 db에서 **삭제**
  - soft-delete은 해당 데이터의 상태를 inactive로 **업데이트** 해준다.
#### 왜 필요한가?
  - [참고](https://dzone.com/articles/to-delete-or-to-soft-delete-that-is-the-question)
  - 주된 이유는 기술적인 이유보다는 사용성 때문..?
    1. History tracking and audit (e.g. for legal reasons)
    2. Keeping reference integrity and avoid cascade delete
    3. You need “Graceful” delete. E.g. a long-running business process may need data that might be “deleted”, but still required for this particular process to finish

### 어떻게 사용하는가?
  - [참고](https://stackoverflow.com/a/33168644)
  - `#{#entityName}` 사용
  - ```java
	 //Override CrudRepository or PagingAndSortingRepository's query method:
	  @Override
	  @Query("select e from #{#entityName} e where e.deleteFlag=false")
	  public List<T> findAll();
    ```
