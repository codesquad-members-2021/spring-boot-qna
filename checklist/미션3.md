
## 미션 3. 로그인 구현

### 로그인 기능 구현
> 로그인이 가능해야 한다.

> 로그인 상태 → 상단 메뉴 : “로그아웃”, “개인정보수정”

> 로그아웃 상태 → 상단 메뉴 : “로그인”, “회원가입”

- [X] 로그인 구현
    - UserController에 login() 메소드 구현
        - url `/users/login`과 매핑
            ```java
            @PostMapping("/login")
            public String login(String userId, String password, HttpSession session) {
                // 로그인 로직 구현
            }
            ```
        - 로그인 성공 시 HttpSession에 로그인 정보 추가
           ```java
            session.setAttribute(“sessionedUser", user);
           ```
    - templates/user/login.html 확인
        - 로그인 form의 action의 url → `/users/login`으로 수정

    - UserRepository
        - userId에 해당하는 데이터 조회
      ```java
      public interface UserRepository extends JpaRepository<User, Long>{
          User findByUserId(String userId);
      }
      ```


- [X] 로그인에 따른 메뉴 처리 구현
    - 세션 설정
        - application.properties
            - handlebars에서 HttpSession 데이터를 접근하기 위한 설정
       ```java
        handlebars.expose-session-attributes=true
       ```
        - URL에 jsessionid가 추가되는 이슈를 해결하는 설정
       ```java
        // spring boot 1.5
        server.session.tracking-modes=cookie
        
        // spring boot 2.x
        server.servlet.session.tracking-modes=cookie
       ```
    - HTML 문서에서 if/else 사용
        - if/else 구문으로 로그인 성공 여부에 따라 띄우는 페이지를 다르게 설정한다.
      ```html
      {{^sessionedUser}}
      [[HTML 구문]
      {{/sessionedUser}}
      {{#sessionedUser}}
      [[HTML 구문]
      {{/sessionedUser}}
      ```
      
   - [X] 로그아웃 기능 구현
      - @GetMapping("/logout")
      - 인자로 HttpSession 받기
      - session.removeAttribute("sessionedUser")
    
### 테스트 데이터 추가
> 로그인 기능을 테스트하기 위해 매번 회원가입을 먼저 해야 한다.

> 로그인 기능을 테스트하는데 어려움이 있다. 테스트 데이터를 미리 추가한 후 개발을 하면 좋겠다.

- [X] 권한 체크에 대한 테스트 데이터 추가
    -  sql 파일을 추가
    - src/main/resources 폴더 아래 data.sql 파일 생성
    - 사용자 데이터 insert sql 쿼리 추가
      ```java
      INSERT INTO USER (id, user_id, password, name, email) VALUES (1, 'javajigi', 'test', '자바지기', 'javajigi@slipp.net');
      INSERT INTO USER (id, user_id, password, name, email) VALUES (2, 'sanjigi', 'test', '산지기', 'sanjigi@slipp.net');
      ```

### 개인정보 수정

> 회원가입한 사용자의 정보를 수정할 수 있어야 한다.

> 이름, 이메일만 수정할 수 있으며, 사용자 아이디는 수정할 수 없다.

> 비밀번호가 일치하는 경우에만 수정 가능하다.

- [X] 개인정보수정 메뉴
    - base.html의 개인정보수정 메뉴에 `/{id}/form` url 링크 추가

- [X] id 체크
    - 로그인한 user의 id와 같을 경우에만 개인정보수정 가능
    - 현재 로그인한 user의 id 가져오기
      ```java
       Object value = session.getAttribute(”sessionedUser");
       if (value != null) {
         User user = (User)value;
       }
      ```
    - 다른 사용자 정보 수정 시도(id 체크에 실패) 시 에러 페이지로 이동

### 질문 기능 구현
> 사용자는 질문을 할 수 있으며, 모든 질문을 볼 수 있다.

> 단, 질문을 할 수 있는 사람은 로그인 사용자만 할 수 있다.

> 질문한 사람은 자신의 글을 수정/삭제할 수 있다.

- [X] 질문하기 구현
    - 글쓴이 입력 필드 삭제
        - Question의 글쓴이 값 == 현재 로그인 한 User의 name 값
    - 로그인하지 않은 사용자가 질문 페이지 접근
        - 로그인 페이지 이동

- [X] 질문 수정하기 구현
    - id 체크
        - 로그인 사용자 id == 글쓴이의 사용자 아이디 체크
        - 수정화면 접근/수정하기 접근 시 체크
    - 로그인하지 않은 사용자 혹은 글쓴이가 아닌 사용자가 질문 페이지 접근
        - 에러 페이지 이동
        - 에러 메시지 "다른 사람의 글을 수정할 수 없다."
    - @PutMapping
        - updateForm.html의 form을 PUT method 값으로 전송
            - `<input type="hidden" name="_method" value="PUT" />` 추가
- [X] 질문 삭제하기 구현
    - id 체크
        - 로그인 사용자 id == 글쓴이의 사용자 아이디 체크
        - 질문 삭제 시도 시 체크
    - 로그인하지 않은 사용자 혹은 글쓴이가 아닌 사용자가 질문 삭제 시도
        - 로그인 페이지 이동
    - @DeleteMapping
        - form을 PUT method 값으로 전송
        - <input type="hidden" name="_method" value="DELETE" /> 추가
    
    
### User와 Question 연결 실습
> 현재 Question의 글쓴이는 User의 name 값을 가지는 것으로 구현했다.

> 이와 같이 구현하는 경우 User의 name을 수정하는 경우 Question의 글쓴이와 다른 값을 가지는 문제가 발생한다. 이 문제를 해결하기 위해 User의 name이 변경될 때마다 Question의 writer 값을 수정할 수도 있지만 이와 같이 구현할 경우 writer가 같은 이름을 가지는 경우 문제가 될 수 있다.

- [X] User의 id를 저장하는 방법 변경
  - User의 primary key인 id 값을 Question에 저장
  - Question을 조회할 때 id 값을 통해 User도 같이 조회
  - @ManyToOne 매핑 활용
    ```java
    @Entity
    public class Question {
        @ManyToOne
        @JoinColumn(foreignKey = @ForeignKey(name = "fk_question_writer"))
        private User writer;

        [...]
    }
    ```

### Answer 구현하기
> 사용자는 질문 상세보기 화면에서 답변 목록을 볼 수 있다.

> 로그인한 사용자는 답변을 추가할 수 있다.

> 자신이 쓴 답변을 삭제할 수 있다.

- [X] Answer 클래스 구현
   - DB와의 매핑
     - `@ManyToOne` : Question - Answer = one-to-many 관계
     - `@JoinColumn` : Question 테이블에 대한 외래키 설정

     ```java
     @Entity
        public class Answer {
            @ManyToOne
            @JoinColumn(foreignKey = @ForeignKey(name = "fk_answer_to_question"))
            private Question question;
        
            [...]
     }
     ```
   - 그밖에 필요한 필드
       - answer 작성자 정보 → User writer 
         - `@ManyToOne` User - Answer = one-to-many 관계
         - `@JoinColumn` : User 테이블에 대한 외래키 설정
       - 작성 시간 → LocalDateTime createAt
       - 내용 → String contents
       - id → Long id

- [ ] AnswerRepository 클래스 구현
   - 특정 Question에 종속되어있는 Answer 목록 조회 메소드
     - findByQuestionId() 추가
    
- [ ] AnswerController 클래스 구현
   - @Controller 어노테이션 추가
     
   - create() 구현
     - 질문하기 기능 수행
     - @PostMapping("/questions/{questionId}/answers/{id}")
     
### refactor

 - [ ] 에러 페이지 만들기
      - QuestionController getForm()
      - UserController updateForm()
 - [ ] ExceptionAdvice 활용
     - 특정 에러 발생 시 에러 페이지로 이동
     - 아래와 같은 코드를 합칠 수 있지 않을까
     ```java
        if (!SessionUtils.isLoginUser(session)) {
            return "redirect:/users/login-form";
        }
        User user = SessionUtils.getLoginUser(session)
                .orElseThrow(() -> new NotFoundException("No login user"));
     ```
 - [X] 세션 사용 코드 리펙토링
    - SessionUtil 클래스 구현

### ???

#### 🤔 어떤게 더 좋은 방식일까?
#### [1]
 ```java
    public void update(String title, String contents) {
        this.title = title;
        this.contents = contents;
    }
 ```
- 좀 더 유연한 구조, 하지만 update할 때 굳이 유연한 구조가 필요할까? 아직 잘 모르겠다.

#### [2]
```java
    public void update(QuestionUpdateRequest question) {
        this.title = question.getTitle();
        this.contents = question.getContents();
    }
```

- question을 업데이트할 시에 QuestionUpdateRequest로 데이터를 받을 때만 수정할 수 있도록 강제할 수 있다.
- QuestionUpdateRequest에 의존적이다. -> 아 이게 좀 많이 걸리는데

#### 🚨 커맨드 객체 기본 생성자, 접근 지시자가 public일 때 문제 발생
#### [해결]
- protected로 수정해준 뒤 정상 동작
- WHY?

#### 🚨 PostMan url 접근 시 뚫리는 문제
  - QuestionController의 update()를 postman을 통해 request를 보내주면 뚫린다.
  - Session 정보 확인으로 막아주어야 한다.

#### 🚨 ID 비교 가능?
- 예를 들어 Question 클래스의 isMatchingWriter() 메소드의 경우 아래와 같이 같은 user임을 확인하기 위해 id를 비교해준다.
    ```java
    public boolean isMatchingWriter(User user){
            return writer.isMatchingId(user.getId());
    }
    ```

- 하지만 id는 자동 increment인데 여기서 발생하는 오류가 생길 수 있지 않나? → 그룹 코드 리뷰에서도 나왔던 문제
- userId로 비교해주어야 하는건가?
