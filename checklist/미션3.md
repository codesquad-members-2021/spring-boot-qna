
## 미션 3. 로그인 구현

### 로그인 기능 구현
> 로그인이 가능해야 한다.

> 로그인 상태 → 상단 메뉴 : “로그아웃”, “개인정보수정”

> 로그아웃 상태 → 상단 메뉴 : “로그인”, “회원가입”

- [X] 로그인 구현
    - UserController에 login() 메소드 구현
        - url `/users/login`과 매핑
            ```java
            @PostMapping("/login")
            public String login(String userId, String password, HttpSession session) {
                // 로그인 로직 구현
            }
            ```
        - 로그인 성공 시 HttpSession에 로그인 정보 추가
           ```java
            session.setAttribute(“sessionedUser", user);
           ```
    - templates/user/login.html 확인
        - 로그인 form의 action의 url → `/users/login`으로 수정

    - UserRepository
        - userId에 해당하는 데이터 조회
      ```java
      public interface UserRepository extends JpaRepository<User, Long>{
          User findByUserId(String userId);
      }
      ```


- [X] 로그인에 따른 메뉴 처리 구현
    - 세션 설정
        - application.properties
            - handlebars에서 HttpSession 데이터를 접근하기 위한 설정
       ```java
        handlebars.expose-session-attributes=true
       ```
        - URL에 jsessionid가 추가되는 이슈를 해결하는 설정
       ```java
        // spring boot 1.5
        server.session.tracking-modes=cookie
        
        // spring boot 2.x
        server.servlet.session.tracking-modes=cookie
       ```
    - HTML 문서에서 if/else 사용
        - if/else 구문으로 로그인 성공 여부에 따라 띄우는 페이지를 다르게 설정한다.
      ```html
      {{^sessionedUser}}
      [[HTML 구문]
      {{/sessionedUser}}
      {{#sessionedUser}}
      [[HTML 구문]
      {{/sessionedUser}}
      ```
      
   - [X] 로그아웃 기능 구현
      - @GetMapping("/logout")
      - 인자로 HttpSession 받기
      - session.removeAttribute("sessionedUser")
    
### 테스트 데이터 추가
> 로그인 기능을 테스트하기 위해 매번 회원가입을 먼저 해야 한다.

> 로그인 기능을 테스트하는데 어려움이 있다. 테스트 데이터를 미리 추가한 후 개발을 하면 좋겠다.

- [X] 권한 체크에 대한 테스트 데이터 추가
    -  sql 파일을 추가
    - src/main/resources 폴더 아래 data.sql 파일 생성
    - 사용자 데이터 insert sql 쿼리 추가
      ```java
      INSERT INTO USER (id, user_id, password, name, email) VALUES (1, 'javajigi', 'test', '자바지기', 'javajigi@slipp.net');
      INSERT INTO USER (id, user_id, password, name, email) VALUES (2, 'sanjigi', 'test', '산지기', 'sanjigi@slipp.net');
      ```

### 개인정보 수정

> 회원가입한 사용자의 정보를 수정할 수 있어야 한다.

> 이름, 이메일만 수정할 수 있으며, 사용자 아이디는 수정할 수 없다.

> 비밀번호가 일치하는 경우에만 수정 가능하다.

- [X] 개인정보수정 메뉴
    - base.html의 개인정보수정 메뉴에 `/{id}/form` url 링크 추가

- [X] id 체크
    - 로그인한 user의 id와 같을 경우에만 개인정보수정 가능
    - 현재 로그인한 user의 id 가져오기
      ```java
       Object value = session.getAttribute(”sessionedUser");
       if (value != null) {
         User user = (User)value;
       }
      ```
    - 다른 사용자 정보 수정 시도(id 체크에 실패) 시 에러 페이지로 이동

### 질문 기능 구현
> 사용자는 질문을 할 수 있으며, 모든 질문을 볼 수 있다.

> 단, 질문을 할 수 있는 사람은 로그인 사용자만 할 수 있다.

> 질문한 사람은 자신의 글을 수정/삭제할 수 있다.

- [X] 질문하기 구현
    - 글쓴이 입력 필드 삭제
        - Question의 글쓴이 값 == 현재 로그인 한 User의 name 값
    - 로그인하지 않은 사용자가 질문 페이지 접근
        - 로그인 페이지 이동

- [X] 질문 수정하기 구현
    - id 체크
        - 로그인 사용자 id == 글쓴이의 사용자 아이디 체크
        - 수정화면 접근/수정하기 접근 시 체크
    - 로그인하지 않은 사용자 혹은 글쓴이가 아닌 사용자가 질문 페이지 접근
        - 에러 페이지 이동
        - 에러 메시지 "다른 사람의 글을 수정할 수 없다."
    - @PutMapping
        - updateForm.html의 form을 PUT method 값으로 전송
            - `<input type="hidden" name="_method" value="PUT" />` 추가
- [X] 질문 삭제하기 구현
    - id 체크
        - 로그인 사용자 id == 글쓴이의 사용자 아이디 체크
        - 질문 삭제 시도 시 체크
    - 로그인하지 않은 사용자 혹은 글쓴이가 아닌 사용자가 질문 삭제 시도
        - 로그인 페이지 이동
    - @DeleteMapping
        - form을 PUT method 값으로 전송
        - <input type="hidden" name="_method" value="DELETE" /> 추가
    
    
### User와 Question 연결 실습
> 현재 Question의 글쓴이는 User의 name 값을 가지는 것으로 구현했다.

> 이와 같이 구현하는 경우 User의 name을 수정하는 경우 Question의 글쓴이와 다른 값을 가지는 문제가 발생한다. 이 문제를 해결하기 위해 User의 name이 변경될 때마다 Question의 writer 값을 수정할 수도 있지만 이와 같이 구현할 경우 writer가 같은 이름을 가지는 경우 문제가 될 수 있다.

- [X] User의 id를 저장하는 방법 변경
  - User의 primary key인 id 값을 Question에 저장
  - Question을 조회할 때 id 값을 통해 User도 같이 조회
  - @ManyToOne 매핑 활용
    ```java
    @Entity
    public class Question {
        @ManyToOne
        @JoinColumn(foreignKey = @ForeignKey(name = "fk_question_writer"))
        private User writer;

        [...]
    }
    ```

### Answer 구현하기
> 사용자는 질문 상세보기 화면에서 답변 목록을 볼 수 있다.

> 로그인한 사용자는 답변을 추가할 수 있다.

> 자신이 쓴 답변을 삭제할 수 있다.

- [X] Answer 클래스 구현
   - DB와의 매핑
     - `@ManyToOne` : Question - Answer = one-to-many 관계
     - `@JoinColumn` : Question 테이블에 대한 외래키 설정

     ```java
     @Entity
        public class Answer {
            @ManyToOne
            @JoinColumn(foreignKey = @ForeignKey(name = "fk_answer_to_question"))
            private Question question;
        
            [...]
     }
     ```
   - 그밖에 필요한 필드
       - answer 작성자 정보 → User writer 
         - `@ManyToOne` User - Answer = one-to-many 관계
         - `@JoinColumn` : User 테이블에 대한 외래키 설정
       - 작성 시간 → LocalDateTime createAt
       - 내용 → String contents
       - id → Long id

- [X] AnswerRepository 인터페이스 구현
   - 특정 Question에 종속되어있는 Answer 목록 조회 메소드
     - findByQuestionId() 추가
    
- [X] AnswerController 클래스 구현
   - @Controller 어노테이션 추가
     
   - create() 구현
     - 질문하기 기능 수행
     - @PostMapping("/questions/{questionId}/answers/")
    
   - delete() 구현
     - 작성된 답변 글 삭제 기능 수행
     - @DeleteMapping("/questions/{questionId}/answers/{id}")
     - 만약 로그인 되어있지 않다면, 로그인 페이지로 이동
     - 로그인한 유저일 경우, session을 통해 id 체크 한 후
       - id 체크 성공 → 해당 답변 글 삭제한 후 questionId를 통해 해당하는 질문 상세페이지 이동
       - id 체크 실패 → 에러 페이지 이동
    
### refactor
- [X] entity에 builder 패턴 적용
  - new 키워드 숨기기
  - 빌더 대신 간단한 정적 팩터리 메서드 사용
    
 - [X] 에러 페이지 만들기
      - QuestionController getForm()
      - UserController updateForm()
    
 - [X] ExceptionAdvice 활용
     - [참고](https://spring.io/blog/2013/11/01/exception-handling-in-spring-mvc)
     - 특정 에러 발생 시 에러 페이지로 이동
     
 - [X] 세션 사용 코드 리펙토링
    - SessionUtil 클래스 구현
   - 아래와 같은 코드를 합칠 수 있지 않을까
     ```java
        if (!SessionUtils.isLoginUser(session)) {
            return "redirect:/users/login-form";
        }
        User user = SessionUtils.getLoginUser(session)
                .orElseThrow(() -> new UserNotFoundException("You are a guest user, please sign in first"));
     ```

### ???

#### 🤔 어떤게 더 좋은 방식일까?
#### [1]
 ```java
    public void update(String title, String contents) {
        this.title = title;
        this.contents = contents;
    }
 ```
- 좀 더 유연한 구조, 하지만 update할 때 굳이 유연한 구조가 필요할까? 아직 잘 모르겠다.

#### [2]
```java
    public void update(QuestionUpdateRequest question) {
        this.title = question.getTitle();
        this.contents = question.getContents();
    }
```

- question을 업데이트할 시에 QuestionUpdateRequest로 데이터를 받을 때만 수정할 수 있도록 강제할 수 있다.
- QuestionUpdateRequest에 의존적이다. -> 아 이게 좀 많이 걸리는데

#### 🚨 커맨드 객체 기본 생성자, 접근 지시자가 public일 때 문제 발생
#### [해결]
- protected로 수정해준 뒤 정상 동작
- WHY?

#### 🚨 PostMan url 접근 시 뚫리는 문제
  - QuestionController의 update()를 postman을 통해 request를 보내주면 뚫린다.
  - Session 정보 확인으로 막아주어야 한다.

#### 🚨 ID 비교 가능?
- 예를 들어 Question 클래스의 isMatchingWriter() 메소드의 경우 아래와 같이 같은 user임을 확인하기 위해 id를 비교해준다.
    ```java
    public boolean isMatchingWriter(User user){
            return writer.isMatchingId(user.getId());
    }
    ```

- 하지만 id는 자동 increment인데 여기서 발생하는 오류가 생길 수 있지 않나? → 그룹 코드 리뷰에서도 나왔던 문제
- userId로 비교해주어야 하는건가?

#### 🚨 JPA 다대일 단방향 VS 다대일 양방향
- Answer : Question 혹은 Answer : User 가 `다대일 단방향`일 경우
  - Answer만 Question과 User를 참조하기 때문에 Question 혹은 User 데이터에 변화가 있을 경우 Answer는 모른다.
    
 - 이런 경우에는 양방향 즉, 서로 참조하도록 해야한다. 단, 순환 참조에 주의
    ```java
    public void addAnswer(Answer answer) {
            answers.add(answer);
            if (answer.getQuestion() != this) {
                answer.setQuestion(this);
            }
        }
    ```
    ```java
    public void setQuestion(Question question) {
            this.question = question;
            if (!question.getAnswers().contains(this)) {
                question.getAnswers().add(this);
            }
        }
    ```
   - 순환 참조에 대한 김영한님의 조언 - [참조](https://www.inflearn.com/questions/14559)
     - API당 별도의 **DTO 클래스**를 만들어서 중간에 엔티티를 DTO로 변환하고, 변환한 DTO를 JSON으로 바꾸시는 것을 권장
     - 아직 100% 와닿지는 않음😂 알아만 두자.
   - 연관관계에 대한 자세한 속성 값들 - [참조](https://data-make.tistory.com/611)

- CascadeType.ALL이 @ManyToOne에 있다는 건
  - 망망망 [참고](https://stackoverflow.com/questions/13027214/what-is-the-meaning-of-the-cascadetype-all-for-a-manytoone-jpa-association)
  - 아래 예시의 경우 Address를 지우면 User가 함께 지워짐. 그리고 해당 User 값을 가지고있던 다른 Address는 고아(orphans)가 됨. 따라서 정상적으로 작동하려면 User에 CascadeType.ALL을 붙여야 한다.
    ```java
    public class User {

        @OneToMany(fetch = FetchType.EAGER)
        protected Set<Address> userAddresses;
    
    }
    
    public class Address {
    
        @ManyToOne(fetch = FetchType.LAZY, cascade = CascadeType.ALL)
        protected User addressOwner;
    
    }
    ```
    
  - [What is the difference between mappedBy and CascadeType.ALL?](https://stackoverflow.com/questions/52030247/what-is-the-difference-between-mappedby-and-cascadetype-all)
    - ONE-TO-MANY relationship between A and B
    - [Option 1] CascadeType
      - 하이버네이트에게 A의 어떤 operation들이 B에게도 적용되는지 알려줌
      - 예를 들어 CascadeType.Remove 설정하지 않았을 경우, A가 remove될 때 B는 remove된다는 보장이 없음
      - ( operation 종류 - "delete" / "remove", "detach" / "evict", "merge", "persist", "save_update" / "update" 등등 아직까지 정확하게는 뭔뜻인지 모르겠다 )
    - [Option 2] mappedBy
      - A와 B가 양방향 관계임을 선언
      - [참고](https://kok202.tistory.com/138)

#### 🚨 mappedBy 이름에 주의하자
 - mappedBy reference an unknown target entity property: 에러 발생 → 원인은 mappedBy 이름을 잘못 표기했기 때문
    [[참고]](https://stackoverflow.com/questions/4011472/mappedby-reference-an-unknown-target-entity-property)
 - User 클래스 내부에서 아래와 같이 "writer"라고 작성해야 한다.
  ```java
    @OneToMany(mappedBy = "writer")
    private List<Answer> answers = new ArrayList<>();
  ```
  - WHY? 내가 Answer 클래스에서 User 필드를 writer라고 선언했기 때문
  ```java
    @ManyToOne
    @JoinColumn(foreignKey = @ForeignKey(name = "fk_answer_writer"))
    private User writer;
  ```

#### 지연 로딩
  - @ManyToOne 속성에 fetch = FetchType.LAZY 추가
  - 실제 사용될 때까지 데이터 로딩을 미룬다.
